[{"title":"结语","type":0,"sectionRef":"#","url":"/simple-web-components/blog/end","content":"记录一下，今天把simple-web-components的文档网站搭建完成，使用的是Docusaurus，还挺灵活好用的。 怎么使用？ 这个js库已经打包压缩放在了NPM库中。 npm i simple-js-tools ","keywords":""},{"title":"初始创立","type":0,"sectionRef":"#","url":"/simple-web-components/blog/first","content":"","keywords":""},{"title":"历史背景​","type":1,"pageTitle":"初始创立","url":"/simple-web-components/blog/first#历史背景","content":"Javascript作为一个脚本语言，却经常被用来当作计算机语言来用，日常的开发使用中，除了浏览器支持的W3C标准API，并没有一个简单、易用的JS库，所以我总结了一些常用方法的库，它是面向函数的。 "},{"title":"按钮","type":0,"sectionRef":"#","url":"/simple-web-components/docs/API/button","content":"","keywords":""},{"title":"禁用 disabled​","type":1,"pageTitle":"按钮","url":"/simple-web-components/docs/API/button#禁用-disabled","content":"&lt;s-button disabled&gt;Button&lt;/s-button&gt;  Button "},{"title":"前言","type":0,"sectionRef":"#","url":"/simple-web-components/docs/API/intro","content":"","keywords":""},{"title":"历史背景​","type":1,"pageTitle":"前言","url":"/simple-web-components/docs/API/intro#历史背景","content":"Web Component是原生Web组件的技术。HeadlessUI提出的无头设计理念，利用Hooks技术，能大大延长组件库的生命周期，毕竟逻辑的迭代要远慢于UI的迭代。 "},{"title":"设计想法​","type":1,"pageTitle":"前言","url":"/simple-web-components/docs/API/intro#设计想法","content":"在设计之初，就确立了每一个方法应该简单、最优，始终相信，最成熟的方法一定是最简单的，最优秀的方法应该同时兼顾方案更简单、性能更好、更安全。 "},{"title":"谦虚的心态​","type":1,"pageTitle":"前言","url":"/simple-web-components/docs/API/intro#谦虚的心态","content":"所有的方法来自个人的原创、网络搜索到结果的总结，难免有方法不够简单、性能不是最好，甚至有漏洞，所以欢迎大家的指正和建议，GitHub已开放了反馈和讨论。 "},{"title":"编码流程​","type":1,"pageTitle":"前言","url":"/simple-web-components/docs/API/intro#编码流程","content":"先有设计文档全网调研编码发布 "},{"title":"快速上手","type":0,"sectionRef":"#","url":"/simple-web-components/docs/API/快速上手","content":"","keywords":""},{"title":"安装​","type":1,"pageTitle":"快速上手","url":"/simple-web-components/docs/API/快速上手#安装","content":""},{"title":"通过 npm 安装​","type":1,"pageTitle":"快速上手","url":"/simple-web-components/docs/API/快速上手#通过-npm-安装","content":"在现有项目中使用 simple-web-components 时，可以通过 npm 进行安装 npm i simple-web-components  当然，你也可以通过 yarn 或 pnpm 进行安装： # 通过 yarn 安装 yarn add simple-web-components # 通过 pnpm 安装 pnpm add simple-web-components  "},{"title":"通过 CDN 安装​","type":1,"pageTitle":"快速上手","url":"/simple-web-components/docs/API/快速上手#通过-cdn-安装","content":"使用 simple-web-components 最简单的方法是直接在 HTML 文件中引入 CDN 链接，之后你可以通过全局变量 sTools 访问到所有方法。 &lt;script src=&quot;https://unpkg.com/browse/simple-web-components@1.0.0-beta.1/dist/simple-web-components.js&quot;&gt; &lt;/script&gt;  "},{"title":"基础","type":0,"sectionRef":"#","url":"/simple-web-components/docs/API/基础","content":"","keywords":""},{"title":"内置方法Hooks​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#内置方法hooks","content":"劫持所有原生方法，在执行内置方法前先执行自定义方法。 "},{"title":"方法要求​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#方法要求","content":"设置方法的isCallback属性为true。返回一个Promise对象。 一个切换禁用属性的例子：  //确定hook的方法 HTMLElementExtends.hooks(&quot;toggleAttribute&quot;) //设置hook方法 toggleDisabled(callback) { if (callback) callback.isHook = true this.disabled = this.toggleAttribute(&quot;disabled&quot;, callback) }  "},{"title":"同步属性 SyncAttributes​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#同步属性-syncattributes","content":"同步自定义元素属性变更到shadowRoot内部元素。 this.syncChild = true  "},{"title":"禁用属性 Disabled​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#禁用属性-disabled","content":""},{"title":"设置禁用属性​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#设置禁用属性","content":"实时编辑器 &lt;div&gt; &lt;s-button disabled&gt;禁用&lt;/s-button&gt; &lt;/div&gt; &lt;div&gt; &lt;s-button disabled&gt;禁用&lt;/s-button&gt; &lt;/div&gt; 结果 Loading... "},{"title":"切换禁用属性 toggleDisabled​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#切换禁用属性-toggledisabled","content":"元素默认绑定了toggleDisabled方法，方法需要返回一个Promise对象。 实时编辑器 &lt;div&gt; &lt;button onClick={()=&gt;{ document.getElementById(&quot;toggleDisabledBtn&quot;).toggleDisabled(()=&gt;{ return new Promise((resolve, reject)=&gt;{ console.log(&quot;toggleDisabled执行了自定义函数&quot;); resolve(); }) }) }} &gt;点击切换禁用属性&lt;/button&gt; &lt;div&gt; &lt;s-button id={&quot;toggleDisabledBtn&quot;}&gt;s-button按钮&lt;/s-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;button onClick={()=&gt;{ document.getElementById(&quot;toggleDisabledBtn&quot;).toggleDisabled(()=&gt;{ return new Promise((resolve, reject)=&gt;{ console.log(&quot;toggleDisabled执行了自定义函数&quot;); resolve(); }) }) }} &gt;点击切换禁用属性&lt;/button&gt; &lt;div&gt; &lt;s-button id={&quot;toggleDisabledBtn&quot;}&gt;s-button按钮&lt;/s-button&gt; &lt;/div&gt; &lt;/div&gt; 结果 Loading... "},{"title":"源码实现​","type":1,"pageTitle":"基础","url":"/simple-web-components/docs/API/基础#源码实现","content":"import stools from &quot;simple-js-tools&quot; //HTMLElement扩展方法 class HTMLElementExtends extends HTMLElement { childNodes;//真实的元素 static get observedAttributes() { return [ &quot;disabled&quot;, ]; } //构造函数 constructor() { super(); // const shadowRoot = this.attachShadow({mode: &quot;open&quot;}); // this.element = this.shadowRoot.childNodes } attributeChangedCallback(name, oldValue, newValue) { // console.log(&quot;attributeChangedCallback&quot;,name, oldValue, newValue) } syncChild = true //是否同步属性变更到子元素 toggleDisabled(callback) { //开启同步属性到子元素 this.syncChild = true if (callback) callback.isHook = true this.toggleAttribute(&quot;disabled&quot;, callback) } } let func = { init: () =&gt; { //布尔值属性的状态（如果属性不存在则添加属性，属性存在则移除属性） func.hooks(&quot;toggleAttribute&quot;) // 同步自定义元素属性到shadowRoot元素 func.syncHook() }, //劫持HTMLElement所有方法 hooks(functionName, callback) { if (!HTMLElementExtends.prototype[functionName].hooked) { const raw_func = HTMLElementExtends.prototype[functionName] // if(functionName === &quot;setAttribute&quot;) console.log(raw_func,1) HTMLElementExtends.prototype[functionName] = function (...args) { let lastParam = (args &amp;&amp; args.length &gt; 0) ? args[args.length - 1] : false if (lastParam &amp;&amp; stools.compare.isFunction(lastParam) &amp;&amp; lastParam.isHook) callback = lastParam if (callback &amp;&amp; stools.compare.isFunction(callback) &amp;&amp; callback.isHook) { callback(arguments, this).then(res =&gt; { arguments[args.length - 1] = undefined // console.log(&quot;[HTMLElement hooks]&quot;, functionName, args) return raw_func.apply(this, arguments) }) } else { console.log(&quot;[HTMLElement]&quot;, functionName, args) return raw_func.apply(this, arguments) } } HTMLElementExtends.prototype[functionName].hooked = true } }, syncHook(callback) { if (!callback) { callback = (args, _this) =&gt; { const name = args[0], oldValue = args[1], newValue = args[2] return new Promise((resolve, reject) =&gt; { // console.log(&quot;attributeChangedCallback Hook!!&quot;, args, _this.syncChild, _this) func.syncAttr(_this, name, oldValue, newValue) resolve() }) } } callback.isHook = true func.hooks(&quot;attributeChangedCallback&quot;, callback) }, syncAttr(_this, name, oldValue, newValue) { if (_this.shadowRoot.childNodes.length &gt; 0 &amp;&amp; _this.syncChild) { const el = _this.shadowRoot.childNodes[0] if (oldValue &amp;&amp; newValue) { el[name] = newValue } else { el.toggleAttribute(name) } console.log(&quot;[HTMLElement syncAttr]&quot;, name, oldValue, newValue) } } } export default { Extends: HTMLElementExtends, ...func }  "}]